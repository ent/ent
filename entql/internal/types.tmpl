{{ define "types" }}
// Copyright 2019-present Facebook Inc. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

// Code generated by internal/gen.go, DO NOT EDIT.

package entql

import "time"

//go:generate go run internal/gen.go

// Fielder is the interface for creating a predicate (entql.P)
// by a field name from the different builder types below.
type Fielder interface {
	Field(string) P
}

{{ range $t := $.Types }}

{{ $titled := ident $t | title  }}
{{ $iface := print $titled "P" }}
{{ $builder := print (ident $t) "P" }}

// {{ $iface }} is the interface for predicates of type {{ $t }} (`type P[{{ $t }}]`).
type {{ $iface }} interface {
	Fielder
	{{ ident $t }}()
}

// {{ $builder }} implements the {{ $iface }} interface.
type {{ $builder }} struct {
	P
	done func(string)
}

func (p *{{ $builder }}) Field(name string) P {
	p.done(name)
	return p.P
}

func (*{{ $builder }}) {{ ident $t }}() {}

{{ range $op := ops $t }}
	// {{ $titled }}{{ $op }} applies the {{ $op }} operation on the given value.
	func {{ $titled }}{{ $op }}(v {{ $t }}) {{ $iface }} {
		field := &Field{}
		value := &Value{V: v}
		done := func(name string) { field.Name = name }
		return &{{ $builder }}{P: {{ $op }}(field, value), done: done}
	}
{{ end }}

// {{ $titled }}Or returns a composed predicate that represents the logical OR predicate.
func {{ $titled }}Or(x, y {{ $iface }}, z ...{{ $iface }}) {{ $iface }} {
	expr := &{{ $builder }}{}
	expr.done = func(name string) {
		zs := make([]P, len(z))
		for i := range z {
			zs[i] = z[i].Field(name)
		}
		expr.P = Or(x.Field(name), y.Field(name), zs...)
	}
	return expr
}

// {{ $titled }}And returns a composed predicate that represents the logical AND predicate.
func {{ $titled }}And(x, y {{ $iface }}, z ...{{ $iface }}) {{ $iface }} {
	expr := &{{ $builder }}{}
	expr.done = func(name string) {
		zs := make([]P, len(z))
		for i := range z {
			zs[i] = z[i].Field(name)
		}
		expr.P = And(x.Field(name), y.Field(name), zs...)
	}
	return expr
}

// {{ $titled }}Not returns a predicate that represents the logical negation of the given predicate.
func {{ $titled }}Not(x {{ $iface }}) {{ $iface }} {
	expr := &{{ $builder }}{}
	expr.done = func(name string) {
		expr.P = Not(x.Field(name))
	}
	return expr
}
{{ end }}

{{ end }}
