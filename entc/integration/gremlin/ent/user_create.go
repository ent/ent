// Copyright 2019-present Facebook Inc. All rights reserved.
// This source code is licensed under the Apache 2.0 license found
// in the LICENSE file in the root directory of this source tree.

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"

	"entgo.io/ent/dialect/gremlin"
	"entgo.io/ent/dialect/gremlin/graph/dsl"
	"entgo.io/ent/dialect/gremlin/graph/dsl/__"
	"entgo.io/ent/dialect/gremlin/graph/dsl/g"
	"entgo.io/ent/dialect/gremlin/graph/dsl/p"
	"entgo.io/ent/entc/integration/gremlin/ent/user"
)

// UserCreate is the builder for creating a User entity.
type UserCreate struct {
	config
	mutation *UserMutation
	hooks    []Hook
}

// SetOptionalInt sets the "optional_int" field.
func (_c *UserCreate) SetOptionalInt(v int) *UserCreate {
	_c.mutation.SetOptionalInt(v)
	return _c
}

// SetNillableOptionalInt sets the "optional_int" field if the given value is not nil.
func (_c *UserCreate) SetNillableOptionalInt(v *int) *UserCreate {
	if v != nil {
		_c.SetOptionalInt(*v)
	}
	return _c
}

// SetAge sets the "age" field.
func (_c *UserCreate) SetAge(v int) *UserCreate {
	_c.mutation.SetAge(v)
	return _c
}

// SetName sets the "name" field.
func (_c *UserCreate) SetName(v string) *UserCreate {
	_c.mutation.SetName(v)
	return _c
}

// SetLast sets the "last" field.
func (_c *UserCreate) SetLast(v string) *UserCreate {
	_c.mutation.SetLast(v)
	return _c
}

// SetNillableLast sets the "last" field if the given value is not nil.
func (_c *UserCreate) SetNillableLast(v *string) *UserCreate {
	if v != nil {
		_c.SetLast(*v)
	}
	return _c
}

// SetNickname sets the "nickname" field.
func (_c *UserCreate) SetNickname(v string) *UserCreate {
	_c.mutation.SetNickname(v)
	return _c
}

// SetNillableNickname sets the "nickname" field if the given value is not nil.
func (_c *UserCreate) SetNillableNickname(v *string) *UserCreate {
	if v != nil {
		_c.SetNickname(*v)
	}
	return _c
}

// SetAddress sets the "address" field.
func (_c *UserCreate) SetAddress(v string) *UserCreate {
	_c.mutation.SetAddress(v)
	return _c
}

// SetNillableAddress sets the "address" field if the given value is not nil.
func (_c *UserCreate) SetNillableAddress(v *string) *UserCreate {
	if v != nil {
		_c.SetAddress(*v)
	}
	return _c
}

// SetPhone sets the "phone" field.
func (_c *UserCreate) SetPhone(v string) *UserCreate {
	_c.mutation.SetPhone(v)
	return _c
}

// SetNillablePhone sets the "phone" field if the given value is not nil.
func (_c *UserCreate) SetNillablePhone(v *string) *UserCreate {
	if v != nil {
		_c.SetPhone(*v)
	}
	return _c
}

// SetPassword sets the "password" field.
func (_c *UserCreate) SetPassword(v string) *UserCreate {
	_c.mutation.SetPassword(v)
	return _c
}

// SetNillablePassword sets the "password" field if the given value is not nil.
func (_c *UserCreate) SetNillablePassword(v *string) *UserCreate {
	if v != nil {
		_c.SetPassword(*v)
	}
	return _c
}

// SetRole sets the "role" field.
func (_c *UserCreate) SetRole(v user.Role) *UserCreate {
	_c.mutation.SetRole(v)
	return _c
}

// SetNillableRole sets the "role" field if the given value is not nil.
func (_c *UserCreate) SetNillableRole(v *user.Role) *UserCreate {
	if v != nil {
		_c.SetRole(*v)
	}
	return _c
}

// SetEmployment sets the "employment" field.
func (_c *UserCreate) SetEmployment(v user.Employment) *UserCreate {
	_c.mutation.SetEmployment(v)
	return _c
}

// SetNillableEmployment sets the "employment" field if the given value is not nil.
func (_c *UserCreate) SetNillableEmployment(v *user.Employment) *UserCreate {
	if v != nil {
		_c.SetEmployment(*v)
	}
	return _c
}

// SetSSOCert sets the "SSOCert" field.
func (_c *UserCreate) SetSSOCert(v string) *UserCreate {
	_c.mutation.SetSSOCert(v)
	return _c
}

// SetNillableSSOCert sets the "SSOCert" field if the given value is not nil.
func (_c *UserCreate) SetNillableSSOCert(v *string) *UserCreate {
	if v != nil {
		_c.SetSSOCert(*v)
	}
	return _c
}

// SetFilesCount sets the "files_count" field.
func (_c *UserCreate) SetFilesCount(v int) *UserCreate {
	_c.mutation.SetFilesCount(v)
	return _c
}

// SetNillableFilesCount sets the "files_count" field if the given value is not nil.
func (_c *UserCreate) SetNillableFilesCount(v *int) *UserCreate {
	if v != nil {
		_c.SetFilesCount(*v)
	}
	return _c
}

// SetCardID sets the "card" edge to the Card entity by ID.
func (_c *UserCreate) SetCardID(id string) *UserCreate {
	_c.mutation.SetCardID(id)
	return _c
}

// SetNillableCardID sets the "card" edge to the Card entity by ID if the given value is not nil.
func (_c *UserCreate) SetNillableCardID(id *string) *UserCreate {
	if id != nil {
		_c = _c.SetCardID(*id)
	}
	return _c
}

// SetCard sets the "card" edge to the Card entity.
func (_c *UserCreate) SetCard(v *Card) *UserCreate {
	return _c.SetCardID(v.ID)
}

// AddPetIDs adds the "pets" edge to the Pet entity by IDs.
func (_c *UserCreate) AddPetIDs(ids ...string) *UserCreate {
	_c.mutation.AddPetIDs(ids...)
	return _c
}

// AddPets adds the "pets" edges to the Pet entity.
func (_c *UserCreate) AddPets(v ...*Pet) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddPetIDs(ids...)
}

// AddFileIDs adds the "files" edge to the File entity by IDs.
func (_c *UserCreate) AddFileIDs(ids ...string) *UserCreate {
	_c.mutation.AddFileIDs(ids...)
	return _c
}

// AddFiles adds the "files" edges to the File entity.
func (_c *UserCreate) AddFiles(v ...*File) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddFileIDs(ids...)
}

// AddGroupIDs adds the "groups" edge to the Group entity by IDs.
func (_c *UserCreate) AddGroupIDs(ids ...string) *UserCreate {
	_c.mutation.AddGroupIDs(ids...)
	return _c
}

// AddGroups adds the "groups" edges to the Group entity.
func (_c *UserCreate) AddGroups(v ...*Group) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddGroupIDs(ids...)
}

// AddFriendIDs adds the "friends" edge to the User entity by IDs.
func (_c *UserCreate) AddFriendIDs(ids ...string) *UserCreate {
	_c.mutation.AddFriendIDs(ids...)
	return _c
}

// AddFriends adds the "friends" edges to the User entity.
func (_c *UserCreate) AddFriends(v ...*User) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddFriendIDs(ids...)
}

// AddFollowerIDs adds the "followers" edge to the User entity by IDs.
func (_c *UserCreate) AddFollowerIDs(ids ...string) *UserCreate {
	_c.mutation.AddFollowerIDs(ids...)
	return _c
}

// AddFollowers adds the "followers" edges to the User entity.
func (_c *UserCreate) AddFollowers(v ...*User) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddFollowerIDs(ids...)
}

// AddFollowingIDs adds the "following" edge to the User entity by IDs.
func (_c *UserCreate) AddFollowingIDs(ids ...string) *UserCreate {
	_c.mutation.AddFollowingIDs(ids...)
	return _c
}

// AddFollowing adds the "following" edges to the User entity.
func (_c *UserCreate) AddFollowing(v ...*User) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddFollowingIDs(ids...)
}

// SetTeamID sets the "team" edge to the Pet entity by ID.
func (_c *UserCreate) SetTeamID(id string) *UserCreate {
	_c.mutation.SetTeamID(id)
	return _c
}

// SetNillableTeamID sets the "team" edge to the Pet entity by ID if the given value is not nil.
func (_c *UserCreate) SetNillableTeamID(id *string) *UserCreate {
	if id != nil {
		_c = _c.SetTeamID(*id)
	}
	return _c
}

// SetTeam sets the "team" edge to the Pet entity.
func (_c *UserCreate) SetTeam(v *Pet) *UserCreate {
	return _c.SetTeamID(v.ID)
}

// SetSpouseID sets the "spouse" edge to the User entity by ID.
func (_c *UserCreate) SetSpouseID(id string) *UserCreate {
	_c.mutation.SetSpouseID(id)
	return _c
}

// SetNillableSpouseID sets the "spouse" edge to the User entity by ID if the given value is not nil.
func (_c *UserCreate) SetNillableSpouseID(id *string) *UserCreate {
	if id != nil {
		_c = _c.SetSpouseID(*id)
	}
	return _c
}

// SetSpouse sets the "spouse" edge to the User entity.
func (_c *UserCreate) SetSpouse(v *User) *UserCreate {
	return _c.SetSpouseID(v.ID)
}

// AddChildIDs adds the "children" edge to the User entity by IDs.
func (_c *UserCreate) AddChildIDs(ids ...string) *UserCreate {
	_c.mutation.AddChildIDs(ids...)
	return _c
}

// AddChildren adds the "children" edges to the User entity.
func (_c *UserCreate) AddChildren(v ...*User) *UserCreate {
	ids := make([]string, len(v))
	for i := range v {
		ids[i] = v[i].ID
	}
	return _c.AddChildIDs(ids...)
}

// SetParentID sets the "parent" edge to the User entity by ID.
func (_c *UserCreate) SetParentID(id string) *UserCreate {
	_c.mutation.SetParentID(id)
	return _c
}

// SetNillableParentID sets the "parent" edge to the User entity by ID if the given value is not nil.
func (_c *UserCreate) SetNillableParentID(id *string) *UserCreate {
	if id != nil {
		_c = _c.SetParentID(*id)
	}
	return _c
}

// SetParent sets the "parent" edge to the User entity.
func (_c *UserCreate) SetParent(v *User) *UserCreate {
	return _c.SetParentID(v.ID)
}

// Mutation returns the UserMutation object of the builder.
func (_c *UserCreate) Mutation() *UserMutation {
	return _c.mutation
}

// Save creates the User in the database.
func (_c *UserCreate) Save(ctx context.Context) (*User, error) {
	_c.defaults()
	return withHooks(ctx, _c.gremlinSave, _c.mutation, _c.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (_c *UserCreate) SaveX(ctx context.Context) *User {
	v, err := _c.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (_c *UserCreate) Exec(ctx context.Context) error {
	_, err := _c.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (_c *UserCreate) ExecX(ctx context.Context) {
	if err := _c.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (_c *UserCreate) defaults() {
	if _, ok := _c.mutation.Last(); !ok {
		v := user.DefaultLast
		_c.mutation.SetLast(v)
	}
	if _, ok := _c.mutation.Address(); !ok {
		v := user.DefaultAddress()
		_c.mutation.SetAddress(v)
	}
	if _, ok := _c.mutation.Role(); !ok {
		v := user.DefaultRole
		_c.mutation.SetRole(v)
	}
	if _, ok := _c.mutation.Employment(); !ok {
		v := user.DefaultEmployment
		_c.mutation.SetEmployment(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (_c *UserCreate) check() error {
	if v, ok := _c.mutation.OptionalInt(); ok {
		if err := user.OptionalIntValidator(v); err != nil {
			return &ValidationError{Name: "optional_int", err: fmt.Errorf(`ent: validator failed for field "User.optional_int": %w`, err)}
		}
	}
	if _, ok := _c.mutation.Age(); !ok {
		return &ValidationError{Name: "age", err: errors.New(`ent: missing required field "User.age"`)}
	}
	if _, ok := _c.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`ent: missing required field "User.name"`)}
	}
	if _, ok := _c.mutation.Last(); !ok {
		return &ValidationError{Name: "last", err: errors.New(`ent: missing required field "User.last"`)}
	}
	if _, ok := _c.mutation.Role(); !ok {
		return &ValidationError{Name: "role", err: errors.New(`ent: missing required field "User.role"`)}
	}
	if v, ok := _c.mutation.Role(); ok {
		if err := user.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf(`ent: validator failed for field "User.role": %w`, err)}
		}
	}
	if _, ok := _c.mutation.Employment(); !ok {
		return &ValidationError{Name: "employment", err: errors.New(`ent: missing required field "User.employment"`)}
	}
	if v, ok := _c.mutation.Employment(); ok {
		if err := user.EmploymentValidator(v); err != nil {
			return &ValidationError{Name: "employment", err: fmt.Errorf(`ent: validator failed for field "User.employment": %w`, err)}
		}
	}
	return nil
}

func (_c *UserCreate) gremlinSave(ctx context.Context) (*User, error) {
	if err := _c.check(); err != nil {
		return nil, err
	}
	res := &gremlin.Response{}
	query, bindings := _c.gremlin().Query()
	if err := _c.driver.Exec(ctx, query, bindings, res); err != nil {
		return nil, err
	}
	if err, ok := isConstantError(res); ok {
		return nil, err
	}
	rnode := &User{config: _c.config}
	if err := rnode.FromResponse(res); err != nil {
		return nil, err
	}
	_c.mutation.id = &rnode.ID
	_c.mutation.done = true
	return rnode, nil
}

func (_c *UserCreate) gremlin() *dsl.Traversal {
	type constraint struct {
		pred *dsl.Traversal // constraint predicate.
		test *dsl.Traversal // test matches and its constant.
	}
	constraints := make([]*constraint, 0, 8)
	v := g.AddV(user.Label)
	if value, ok := _c.mutation.OptionalInt(); ok {
		v.Property(dsl.Single, user.FieldOptionalInt, value)
	}
	if value, ok := _c.mutation.Age(); ok {
		v.Property(dsl.Single, user.FieldAge, value)
	}
	if value, ok := _c.mutation.Name(); ok {
		v.Property(dsl.Single, user.FieldName, value)
	}
	if value, ok := _c.mutation.Last(); ok {
		v.Property(dsl.Single, user.FieldLast, value)
	}
	if value, ok := _c.mutation.Nickname(); ok {
		constraints = append(constraints, &constraint{
			pred: g.V().Has(user.Label, user.FieldNickname, value).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueField(user.Label, user.FieldNickname, value)),
		})
		v.Property(dsl.Single, user.FieldNickname, value)
	}
	if value, ok := _c.mutation.Address(); ok {
		v.Property(dsl.Single, user.FieldAddress, value)
	}
	if value, ok := _c.mutation.Phone(); ok {
		constraints = append(constraints, &constraint{
			pred: g.V().Has(user.Label, user.FieldPhone, value).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueField(user.Label, user.FieldPhone, value)),
		})
		v.Property(dsl.Single, user.FieldPhone, value)
	}
	if value, ok := _c.mutation.Password(); ok {
		v.Property(dsl.Single, user.FieldPassword, value)
	}
	if value, ok := _c.mutation.Role(); ok {
		v.Property(dsl.Single, user.FieldRole, value)
	}
	if value, ok := _c.mutation.Employment(); ok {
		v.Property(dsl.Single, user.FieldEmployment, value)
	}
	if value, ok := _c.mutation.SSOCert(); ok {
		v.Property(dsl.Single, user.FieldSSOCert, value)
	}
	if value, ok := _c.mutation.FilesCount(); ok {
		v.Property(dsl.Single, user.FieldFilesCount, value)
	}
	for _, id := range _c.mutation.CardIDs() {
		v.AddE(user.CardLabel).To(g.V(id)).OutV()
		constraints = append(constraints, &constraint{
			pred: g.E().HasLabel(user.CardLabel).InV().HasID(id).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge(user.Label, user.CardLabel, id)),
		})
	}
	for _, id := range _c.mutation.PetsIDs() {
		v.AddE(user.PetsLabel).To(g.V(id)).OutV()
		constraints = append(constraints, &constraint{
			pred: g.E().HasLabel(user.PetsLabel).InV().HasID(id).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge(user.Label, user.PetsLabel, id)),
		})
	}
	for _, id := range _c.mutation.FilesIDs() {
		v.AddE(user.FilesLabel).To(g.V(id)).OutV()
		constraints = append(constraints, &constraint{
			pred: g.E().HasLabel(user.FilesLabel).InV().HasID(id).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge(user.Label, user.FilesLabel, id)),
		})
	}
	for _, id := range _c.mutation.GroupsIDs() {
		v.AddE(user.GroupsLabel).To(g.V(id)).OutV()
	}
	for _, id := range _c.mutation.FriendsIDs() {
		v.AddE(user.FriendsLabel).To(g.V(id)).OutV()
	}
	for _, id := range _c.mutation.FollowersIDs() {
		v.AddE(user.FollowingLabel).From(g.V(id)).InV()
	}
	for _, id := range _c.mutation.FollowingIDs() {
		v.AddE(user.FollowingLabel).To(g.V(id)).OutV()
	}
	for _, id := range _c.mutation.TeamIDs() {
		v.AddE(user.TeamLabel).To(g.V(id)).OutV()
		constraints = append(constraints, &constraint{
			pred: g.E().HasLabel(user.TeamLabel).InV().HasID(id).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge(user.Label, user.TeamLabel, id)),
		})
	}
	for _, id := range _c.mutation.SpouseIDs() {
		v.AddE(user.SpouseLabel).To(g.V(id)).OutV()
		constraints = append(constraints, &constraint{
			pred: g.E().HasLabel(user.SpouseLabel).InV().HasID(id).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge(user.Label, user.SpouseLabel, id)),
		})
	}
	for _, id := range _c.mutation.ChildrenIDs() {
		v.AddE(user.ParentLabel).From(g.V(id)).InV()
		constraints = append(constraints, &constraint{
			pred: g.E().HasLabel(user.ParentLabel).OutV().HasID(id).Count(),
			test: __.Is(p.NEQ(0)).Constant(NewErrUniqueEdge(user.Label, user.ParentLabel, id)),
		})
	}
	for _, id := range _c.mutation.ParentIDs() {
		v.AddE(user.ParentLabel).To(g.V(id)).OutV()
	}
	if len(constraints) == 0 {
		return v.ValueMap(true)
	}
	tr := constraints[0].pred.Coalesce(constraints[0].test, v.ValueMap(true))
	for _, cr := range constraints[1:] {
		tr = cr.pred.Coalesce(cr.test, tr)
	}
	return tr
}

// UserCreateBulk is the builder for creating many User entities in bulk.
type UserCreateBulk struct {
	config
	err      error
	builders []*UserCreate
}
