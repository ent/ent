{{/*
Copyright 2019-present Facebook Inc. All rights reserved.
This source code is licensed under the Apache 2.0 license found
in the LICENSE file in the root directory of this source tree.
*/}}

{{/* gotype: entgo.io/ent/entc/gen.Type */}}

{{ define "update" }}
{{ $pkg := base $.Config.Package }}

{{ template "header" $ }}

{{ with extend $ "Imports" $.SiblingImports }}
	{{ template "import" . }}
{{ end }}

{{ $builder := $.UpdateName }}
{{ $runtimeRequired := or $.NumHooks $.NumPolicy }}

// {{ $builder }} is the builder for updating {{ $.Name }} entities.
type {{ $builder }} struct {
	config
	{{- template "update/fields" $ -}}
}

// Where appends a list predicates to the {{ $builder }} builder.
func (u *{{ $builder }}) Where(ps ...predicate.{{ $.Name }}) *{{ $builder }} {
	u.mutation.Where(ps...)
	return u
}

{{ with extend $ "Receiver" "u" "Builder" $builder }}
	{{ template "setter" . }}
{{ end }}

{{ with extend $ "Receiver" "u" "Builder" $builder }}
	{{ template "update/edges" . }}
{{ end }}

// Save executes the query and returns the number of nodes affected by the update operation.
func (u *{{ $builder }}) Save(ctx context.Context) (int, error) {
	{{- if $.HasUpdateDefault }}
		{{- if $runtimeRequired }}
			if err := u.defaults(); err != nil {
				return 0, err
			}
		{{- else }}
			u.defaults()
		{{- end }}
	{{- end }}
	return withHooks(ctx, u.{{ $.Storage }}Save, u.mutation, u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (u *{{ $builder }}) SaveX(ctx context.Context) int {
	affected, err := u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (u *{{ $builder }}) Exec(ctx context.Context) error {
	_, err := u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (u *{{ $builder }}) ExecX(ctx context.Context) {
	if err := u.Exec(ctx); err != nil {
		panic(err)
	}
}

{{ with extend $ "Receiver" "u" "Package" $pkg "Builder" $builder }}
	{{ template "update/checks" . }}
{{ end }}

{{ with extend $ "Receiver" "u" "Builder" $builder "Package" $pkg }}
	{{ $tmpl := printf "dialect/%s/update" $.Storage }}
	{{ xtemplate $tmpl . }}
{{ end }}

{{ $onebuilder := $.UpdateOneName }}

// {{ $onebuilder }} is the builder for updating a single {{ $.Name }} entity.
type {{ $onebuilder }} struct {
	config
	fields []string
	{{- template "update/fields" $ }}
}

{{ with extend $ "Receiver" "u" "Builder" $onebuilder }}
	{{ template "setter" . }}
{{ end }}


{{ with extend $ "Receiver" "u" "Builder" $onebuilder }}
	{{ template "update/edges" . }}
{{ end }}

// Where appends a list predicates to the {{ $builder }} builder.
func (u *{{ $onebuilder }}) Where(ps ...predicate.{{ $.Name }}) *{{ $onebuilder }} {
	u.mutation.Where(ps...)
	return u
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (u *{{ $onebuilder }}) Select(field string, fields ...string) *{{ $onebuilder }} {
	u.fields = append([]string{field}, fields...)
	return u
}

// Save executes the query and returns the updated {{ $.Name }} entity.
func (u *{{ $onebuilder }} ) Save(ctx context.Context) (*{{ $.Name }}, error) {
	{{- if $.HasUpdateDefault }}
		{{- if $runtimeRequired }}
			if err := u.defaults(); err != nil {
				return nil, err
			}
		{{- else }}
			u.defaults()
		{{- end }}
	{{- end }}
	return withHooks(ctx, u.{{ $.Storage }}Save, u.mutation, u.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (u *{{ $onebuilder }}) SaveX(ctx context.Context) *{{ $.Name }} {
	node, err := u.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (u *{{ $onebuilder }}) Exec(ctx context.Context) error {
	_, err := u.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (u *{{ $onebuilder }}) ExecX(ctx context.Context) {
	if err := u.Exec(ctx); err != nil {
		panic(err)
	}
}

{{ with extend $ "Receiver" "u" "Package" $pkg "Builder" $onebuilder }}
	{{ template "update/checks" . }}
{{ end }}

{{ with extend $ "Receiver" "u" "Builder" $onebuilder "Package" $pkg }}
	{{ $tmpl := printf "dialect/%s/update" $.Storage }}
	{{ xtemplate $tmpl . }}
{{ end }}

{{- /* Support adding update methods by global templates. */}}
{{- with $tmpls := matchTemplate "update/additional/*" }}
	{{- range $tmpl := $tmpls }}
		{{ xtemplate $tmpl $ }}
	{{- end }}
{{- end }}

{{ end }}

{{/* shared struct fields between the two updaters */}}
{{ define "update/fields"}}
	hooks []Hook
	mutation *{{ $.MutationName }}
	{{- /* Additional fields to add to the builder. */}}
	{{- $tmpl := printf "dialect/%s/update/fields" $.Storage }}
	{{- if hasTemplate $tmpl }}
		{{- xtemplate $tmpl . }}
	{{- end }}
{{ end }}

{{/* shared edges removal between the two updaters */}}
{{ define "update/edges" }}
{{ $builder := pascal .Scope.Builder }}

{{ range $e := $.EdgesWithID }}
	{{ if $e.Immutable }}
		{{/* Skip to the next one as immutable edges cannot be updated. */}}
		{{continue}}
	{{ end }}
	{{ $func := $e.MutationClear }}
	// {{ $func }} clears {{ if $e.Unique }}the "{{ $e.Name }}" edge{{ else }}all "{{ $e.Name }}" edges{{ end }} to the {{ $e.Type.Name }} entity.
	func (u *{{ $builder }}) {{ $func }}() *{{ $builder }} {
		u.mutation.{{ $func }}()
		return u
	}
	{{ if not $e.Unique }}
		{{ $idsFunc := print "Remove" (singular $e.Name | pascal) "IDs" }}
		// {{ $idsFunc }} removes the "{{ $e.Name }}" edge to {{ $e.Type.Name }} entities by IDs.
		func (u *{{ $builder }}) {{ $idsFunc }}(ids ...{{ $e.Type.ID.Type }}) *{{ $builder }} {
			u.mutation.{{ $idsFunc }}(ids...)
			return u
		}
		{{ $func := print "Remove" $e.StructField }}
		// {{ $func }} removes "{{ $e.Name }}" edges to {{ $e.Type.Name }} entities.
		func (u *{{ $builder }}) {{ $func }}(v ...*{{ $e.Type.Name }}) *{{ $builder }} {
			ids := make([]{{ $e.Type.ID.Type }}, len(v))
			for i := range v {
				ids[i] = v[i].ID
			}
			return u.{{ $idsFunc }}(ids...)
		}
	{{ end }}
{{ end }}
{{ end }}

{{/* shared template for the 2 update builders */}}
{{ define "update/checks" }}
{{ $pkg := .Scope.Package }}
{{ $builder := pascal .Scope.Builder }}
{{ $runtimeRequired := or $.NumHooks $.NumPolicy }}

{{ if $.HasUpdateDefault }}
	// defaults sets the default values of the builder before save.
	func (u *{{ $builder }}) defaults() {{ if $runtimeRequired }}error{{ end }}{
		{{- range $f := $.Fields }}
			{{- if $f.UpdateDefault }}
				if _, ok := u.mutation.{{ $f.MutationGet }}(); !ok {{ if $f.Optional }} && !u.mutation.{{ $f.StructField }}Cleared() {{ end }} {
					{{- if $runtimeRequired }}
						if {{ $.Package }}.{{ $f.UpdateDefaultName }} == nil {
							return fmt.Errorf("{{ $pkg }}: uninitialized {{ $.Package }}.{{ $f.UpdateDefaultName }} (forgotten import {{ $pkg }}/runtime?)")
						}
					{{- end }}
					v := {{ $.Package }}.{{ $f.UpdateDefaultName }}()
					u.mutation.{{ $f.MutationSet }}(v)
				}
			{{- end }}
		{{- end }}
		{{- if $runtimeRequired }}
			return nil
		{{- end }}
	}
{{ end }}

{{ if $.HasUpdateCheckers }}
	// check runs all checks and user-defined validators on the builder.
	func (u *{{ $builder }}) check() error {
		{{- range $f := $.Fields }}
			{{- $isValidator := and ($f.HasGoType) ($f.Type.Validator) }}
			{{- with and (not $f.Immutable) (or $f.Validators $f.IsEnum $isValidator) }}
				if v, ok := u.mutation.{{ $f.MutationGet }}(); ok {
					if err := {{ if or $f.Validators $f.IsEnum }}{{ $.Package }}.{{ $f.Validator }}({{ $f.BasicType "v" }}){{ else }}v.Validate(){{ end }}; err != nil {
						return &ValidationError{Name: "{{ $f.Name }}", err: fmt.Errorf(`{{ $pkg }}: validator failed for field "{{ $.Name }}.{{ $f.Name }}": %w`, err)}
					}
				}
			{{- end }}
		{{- end }}
		{{- range $e := $.Edges }}
			{{- if and $e.Unique (not $e.Optional) }}
				if u.mutation.{{ $e.StructField }}Cleared() && len(u.mutation.{{ $e.StructField }}IDs()) > 0 {
					return errors.New(`{{ $pkg }}: clearing a required unique edge "{{ $.Name }}.{{ $e.Name }}"`)
				}
			{{- end }}
		{{- end }}
		return nil
	}
{{ end }}

{{ end }}
