---
id: graphql
title: GraphQL Integration
---

`ent`框架通过[99designs/gqlgen](https://github.com/99designs/gqlgen) 提供图的集成。
库使用[external templates](templates.md) 选项（也就是说它能够继承支持其他库）

## 快速开始

为了使[`entgql`](https://github.com/facebookincubator/ent-contrib/tree/master/entgql)扩展到你的项目可以使用，你需要使用 `entc`包，
介绍在[here](code-gen.md#use-entc-as-a-package)。
以下三个步骤使它在你的项目中可用。

1\. 创建一个名为`ent/entc.go`的Go文件，粘贴以下内容。

```go
// +build ignore

package main

import (
	"log"

	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
	"entgo.io/contrib/entgql"
)

func main() {
	err := entc.Generate("./schema", &gen.Config{
		Templates: entgql.AllTemplates,
	})
	if err != nil {
		log.Fatalf("running ent codegen: %v", err)
	}
}
```

2\. 编辑`ent/generate.go`并执行：

```go
package ent

//go:generate go run entc.go
```

注意`ent/entc.go`使用build是被忽略的，它通过`go generate`命令执行。
完整的案例在[ent-contrib repository](https://github.com/facebookincubator/ent-contrib/blob/master/entgql/internal/todo).

3\. 在你的ent项目下执行如下命令：

```console
go generate ./...
```

在执行完成后，以下程序将添加到项目中

## Node API

一个新的名为`ent/node.go`的文件被创建，它实现了[Relay Node interface](https://relay.dev/docs/en/graphql-server-specification.html#object-identification)接口。

为了在[GraphQL resolver](https://gqlgen.com/reference/resolvers/)中使用新生成的`ent.Noder`接口，
添加`Node`方法到查询resolver中，请查看[configuration](#gql-configuration)去理解怎么使用。

如果在schema 迁移使用[Universal IDs](migrate.md#universal-ids)，NodeType派生自id值，可以如下使用:

```go
func (r *queryResolver) Node(ctx context.Context, id int) (ent.Noder, error) {
	return r.client.Noder(ctx, id)
}
```

然而，如果你使用自定义的全局唯一标识，你能够控制NodeType：

```go
func (r *queryResolver) Node(ctx context.Context, guid string) (ent.Noder, error) {
	typ, id := parseGUID(guid)
	return r.client.Noder(ctx, id, ent.WithNodeType(typ))
}
```


## GQL配置

这里有一些APP配置的案例[ent-contrib/entgql/todo](https://github.com/facebookincubator/ent-contrib/tree/master/entgql/internal/todo).

```yaml
schema:
  - todo.graphql

resolver:
  # Tell gqlgen to generate resolvers next to the schema file.
  layout: follow-schema
  dir: .

# gqlgen will search for any type names in the schema in the generated
# ent package. If they match it will use them, otherwise it will new ones.
autobind:
  - entgo.io/contrib/entgql/internal/todo/ent

models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.IntID
  Node:
    model:
      # ent.Noder is the new interface generated by the Node template.
      - entgo.io/contrib/entgql/internal/todo/ent.Noder
```

## 分区

分区模板添加了根据 _Relay Cursor Connections Spec_ 分页支持。更多关于Relay Spec的信息在[website](https://relay.dev/graphql/connections.htm).

## 连接顺序

顺序选项允许我们对连接返回的关系应用排序。

### 使用笔记

- 如果保留了命名约定，生成类型将被`autobind`到GraphQL类型
- 排序仅仅能够被定义在ent字段（无关系的）
- 排序字段通常要设置索引[indexed](schema-indexes.md)，避免全表扫描
- 分页查询能够通过单个字段排序

### 案例

让我们回顾一下向现有的GraphQL类型添加排序所需的步骤。
代码案例在[ent-contrib/entql/todo](https://github.com/facebookincubator/ent-contrib/tree/master/entgql/internal/todo)

### 在ent/schema中定义要排序的字段

通过`entgql.Annotation`注释，排序能够被定义在ent中任可比较的字段中
注意`OrderField`必须匹配它在graphql schema中的枚举值
```go
func (Todo) Fields() []ent.Field {
    return []ent.Field{
	    field.Time("created_at").
			Default(time.Now).
			Immutable().
			Annotations(
				entgql.OrderField("CREATED_AT"),
			),
		field.Enum("status").
			NamedValues(
				"InProgress", "IN_PROGRESS",
				"Completed", "COMPLETED",
			).
			Annotations(
				entgql.OrderField("STATUS"),
			),
		field.Int("priority").
			Default(0).
			Annotations(
				entgql.OrderField("PRIORITY"),
			),
		field.Text("text").
			NotEmpty().
			Annotations(
				entgql.OrderField("TEXT"),
			),
    }
}
```
所有schema的改变都是需要的，确保运行`go generate`应用它们：

### 在GraphQL schema中定义排序类型

下一步我们需要在GraphQL schema中定义排序类型
```graphql
enum OrderDirection {
  ASC
  DESC
}

enum TodoOrderField {
  CREATED_AT
  PRIORITY
  STATUS
  TEXT
}

input TodoOrder {
  direction: OrderDirection!
  field: TodoOrderField
}
```
注意这些命名必须要用`<T>OrderField` / `<T>Order`去生成ent类型。
[@goModel](https://gqlgen.com/config/#inline-config-with-directives) 指令可以通过手动类型去绑定

### 添加orderBy参数给分页查询
```graphql
type Query {
  todos(
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: TodoOrder
  ): TodoConnection
}
```
这就是所有GraphQL schema的改变，让我们运行：`gqlgen`生成代码

### 更新依赖resolver

从头去做resolver，更新`orderBy`参数到`.Paginate()`调用。

```go
func (r *queryResolver) Todos(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TodoOrder) (*ent.TodoConnection, error) {
	return r.client.Todo.Query().
		Paginate(ctx, after, first, before, last,
			ent.WithTodoOrder(orderBy),
		)
}
```

### Use in GraphQL

```text
query {
    todos(first: 3, orderBy: {direction: DESC, field: NAME}) {
        edges {
            node {
                name
            }
        }
    }
}
```

## 字段集合

集合模板添加支持了自动[GraphQL fields collection](https://spec.graphql.org/June2018/#sec-Field-Collection)，对于ent-关系使用了贪婪加载。
这意味着，如果一个查询访问节点和它们的关系，entgql将会自动添加[`With<E>`](eager-load.md#api)步骤到root查询，最后，客户端将对数据库执行固定数量的查询——并且递归工作。

例子，给一个GraphQL查询：

```graphql
query {
  users(first: 100) {
    edges {
      node {
        photos {
          link
        }
        posts {
          content
          comments {
            content
          }
        }
      }
    }
  }
}
```

客户端将执行1个查询去获取用户，1个获取照片，其他2个获取文章和他们的评论（总共4个）。
这些逻辑工作同时支持root的queries/resolvers和node(s)API。

### Schema 配置

为了配置这些选项给特殊的关系，使用`entgql.Annotation`：

```go
func (Todo) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("children", Todo.Type).
            Annotations(entgql.Bind()).
            From("parent").
            // Bind implies the edge name in graphql schema is
            // equivalent to the name used in ent schema.
            Annotations(entgql.Bind()).
            Unique(),
        edge.From("owner", User.Type).
            Ref("tasks").
            // Map edge names as defined in graphql schema.
            Annotations(entgql.MapsTo("taskOwner")),
    }
}
```

### 使用和配置

GraphQL扩展还为节点生成边缘解析器，文件如下：
```go
func (t *Todo) Children(ctx context.Context) ([]*Todo, error) {
	result, err := t.Edges.ChildrenOrErr()
	if IsNotLoaded(err) {
		result, err = t.QueryChildren().All(ctx)
	}
	return result, err
}
```

然而，如果你想明确的写一些解析器，你可以添加[`forceResolver`](https://gqlgen.com/master/config#inline-config-with-directives)
选项到你的GraphQL schema：

```graphql
type Todo implements Node {
  id: ID!
  children: [Todo]! @goField(forceResolver: true)
}
```

然后，你可以实现自己的解析器

```go
func (r *todoResolver) Children(ctx context.Context, obj *ent.Todo) ([]*ent.Todo, error) {
	// Do something here.
	return obj.Edges.ChildrenOrErr()
}
```

## Enum实现

enum模板为ent生成的enum实现了MarshalGQL/UnmarshalGQL方法

## 事务变化

`entgql.Transactioner`处理器执行每个在事务的GraphQL变化，对于解析器注入的客户端是一个[transactional `ent.Client`](transactions.md#transactional-client).
因此，代码使用`ent.Client`不需要被改变，使用如下：

1\. 在GraphQL server初始化，使用`entgql.Transactioner` 处理器

```go
srv := handler.NewDefaultServer(todo.NewSchema(client))
srv.Use(entgql.Transactioner{TxOpener: client})
```

2\. 然后，在GraphQL变化使用来自context的client
```go
func (mutationResolver) CreateTodo(ctx context.Context, todo TodoInput) (*ent.Todo, error) {
	client := ent.FromContext(ctx)
	return client.Todo.
		Create().
		SetStatus(todo.Status).
		SetNillablePriority(todo.Priority).
		SetText(todo.Text).
		SetNillableParentID(todo.Parent).
		Save(ctx)
}
```

## 案例

1. 一个完整的GraphQL server。[Todo App](https://github.com/facebookincubator/ent-contrib/tree/master/entgql/internal/todo)有数据ID字段的。
2. 和[Todo App](https://github.com/facebookincubator/ent-contrib/tree/master/entgql/internal/todouuid)1相似，但是ID字段是UUID
3. 和[Todo App](https://github.com/facebookincubator/ent-contrib/tree/master/entgql/internal/todouuid)1、2相似。但是有前缀 [ULID](https://github.com/ulid/spec) 或者
`PULID`作为ID字段。这个示例支持中继节点API，方法是使用实体类型作为ID的前缀，而不是使用在[Universal IDs](migrate.md#universal-ids)ID空间分区.

---

请注意这些文档都是依赖于开发，所有的代码部分属于[ent-contrib/entgql](https://github.com/facebookincubator/ent-contrib/tree/master/entgql)，
这个todo-app的例子在[ent-contrib/entql/todo](https://github.com/facebookincubator/ent-contrib/tree/master/entgql/internal/todo).
